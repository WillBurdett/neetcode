package practise;

public class PractisePad {

  /**
   * You are given an array of distinct integers nums, sorted in ascending order, and an integer target.
   *
   * Implement a function to search for target within nums. If it exists, then return its index, otherwise, return -1.
   *
   * Your solution must run in O(logn) time.
   *
   * Example 1:
   *
   * Input: nums = [-1,0,2,4,6,8], target = 4
   *
   * Output: 3
   * Example 2:
   *
   * Input: nums = [-1,0,2,4,6,8], target = 3
   *
   * Output: -1
   * Constraints:
   *
   * 1 <= nums.length <= 10000.
   * -10000 < nums[i], target < 10000
   **/
  public int search(int[] nums, int target) {
    return -1;
  }

  /**
   * You are given an m x n 2-D integer array matrix and an integer target.
   *
   * Each row in matrix is sorted in non-decreasing order.
   * The first integer of every row is greater than the last integer of the previous row.
   * Return true if target exists within matrix or false otherwise.
   *
   * Can you write a solution that runs in O(log(m * n)) time?
   *
   * Example 1:
   * Input: matrix = [[1,2,4,8],[10,11,12,13],[14,20,30,40]], target = 10
   * Output: true
   *
   *
   * Example 2:
   * Input: matrix = [[1,2,4,8],[10,11,12,13],[14,20,30,40]], target = 15
   * Output: false
   *
   * Constraints:
   * m == matrix.length
   * n == matrix[i].length
   * 1 <= m, n <= 100
   * -10000 <= matrix[i][j], target <= 10000
   */
  public boolean searchMatrix(int[][] matrix, int target) {
    return false;
  }

  public int minEatingSpeed(int[] piles, int h) {
    return 0;
  }

  public int findMin(int[] nums) {
    return 0;
  }

  public int searchRotated(int[] nums, int target) {
    return 0;
  }

  // Complete TimeMap in TimeMap class

  public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    return 0;
  }
}
